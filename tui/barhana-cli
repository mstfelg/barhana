#!/usr/bin/env python

import re
from enum import Enum

from prompt_toolkit import PromptSession
from prompt_toolkit.completion import WordCompleter
from prompt_toolkit.lexers import PygmentsLexer
from pygments.lexers.python import PythonLexer
from sympy.logic import boolalg

from barhana.rules import *

DERIV_CHMODE = {
    'PREMISE': [
    ],
    'CLAIM': [
        'claim',
        'claim_not',
        'claim_cons',
    ],
    'ASSUME': [
        'let_not',
        'let_ante',
    ],
    'STATE': [
        'modp',
        'modt',
        'de_morgans',
    ],
}

DERIV_PREFIX = {
    'PREMISE': 'pr',
    'CLAIM': 'cl',
    'ASSUME': 'if',
    'STATE': 'st',
}

deriv_mode = {
    'PREMISE': [],
    'CLAIM': [],
    'ASSUME': [],
    'STATE': [],
}

cur_mode = 'PREMISE'
cur_scope = 'Set premises'
namespace = { }

def usage():
    """ Print help message """
    print("""
            Barhana: logical derivation engine.
            ---
            display: display a list of provided premises, claims, assumptions
                     or statements.

            help:    Show this message.
          """)

def show_deriv(query=None):
    if query:
        ans = deriv_mode.get(query.upper())
        if not ans:
            ans = "Invalid mode"
        print(ans)
        return
    for mode, stat in deriv_mode.items():
        print(mode)
        print(stat)
    print('VARIABLES')
    print(namespace)

BUILT_INS = {
    'help': usage,
    'def': lambda x: exec(f"{x} = symbols('{x}')", globals(), namespace),
    'ls': show_deriv,
}

barhana_completer = WordCompleter([
        item for sublist in DERIV_CHMODE.values() for item in sublist
    ] + list(BUILT_INS.keys()), ignore_case=True)

def update_mode(arg):
    """ Parses argument for a keyword to change mode """

    for mode in DERIV_CHMODE:
        if arg in DERIV_CHMODE[mode]:
            global cur_mode, cur_scope
            cur_mode = cur_scope = mode

            return

def main():
    """ Main routine """
    session = PromptSession(lexer=PygmentsLexer(PythonLexer),
                            completer=barhana_completer)

    while True:
        try:
            inp_count = str(len(deriv_mode[cur_mode]))
            inp = session.prompt(f'[ {cur_mode}{inp_count} ]: ', rprompt=cur_scope)
        except KeyboardInterrupt:
            continue
        except EOFError:
            break

        arg_list = re.split(r'\s+', inp)
        arg_list = [arg for arg in arg_list if arg]
        cmd = re.match(r'(\w+)\((.*)\)', inp)

        if cmd:
            cmd = cmd.group(1)
        else:
            cmd = arg_list[0]

        if func := BUILT_INS.get(cmd):
            try:
                func(*arg_list[1:])
            except Exception as err:
                print("Invalid command")
                print(repr(err))

            continue

        update_mode(cmd)
        dvar = DERIV_PREFIX[cur_mode]
        dcount = len(deriv_mode[cur_mode])

        try:
            exec(f"{dvar}{dcount:02d} = " + inp, globals(), namespace)
            deriv_mode[cur_mode].append(inp)

        except Exception as err:
            print(repr(err))

if __name__ == '__main__':
    main()
